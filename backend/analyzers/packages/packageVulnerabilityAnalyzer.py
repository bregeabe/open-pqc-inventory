import subprocess
import json
import re
import argparse
from collections import defaultdict, deque
from typing import Dict, List, Set, Optional, Tuple, Any
from datetime import datetime


class PackageVulnerabilityDatabase:
    def __init__(self):
        self.vulnerable_packages = {
            "openssl": {
                "category": "cryptographic",
                "severity": "critical",
                "reason": "Core SSL/TLS implementation, quantum-vulnerable algorithms",
                "pqc_impact": "high",
                "alternatives": ["openssl3-quantum", "boringssl-pqc"]
            },
            "libssl1.1": {
                "category": "cryptographic", 
                "severity": "critical",
                "reason": "OpenSSL 1.1.x library with quantum-vulnerable ciphers",
                "pqc_impact": "high",
                "alternatives": ["libssl3"]
            },
            "libssl3": {
                "category": "cryptographic",
                "severity": "medium", 
                "reason": "May lack post-quantum algorithms depending on version",
                "pqc_impact": "medium",
                "alternatives": ["custom-pqc-build"]
            },

            
            "libssh-gcrypt-4:amd64": {
                "category": "ssh",
                "severity": "high",
                "reason": "SSH library using classical cryptography",
                "pqc_impact": "high", 
                "alternatives": ["openssh-pqc"]
            },
            "libssh2-1": {
                "category": "ssh",
                "severity": "high",
                "reason": "SSH2 library without post-quantum support",
                "pqc_impact": "high",
                "alternatives": ["libssh2-pqc"]
            },
            "openssh-client": {
                "category": "ssh",
                "severity": "medium",
                "reason": "Standard SSH client, no PQC algorithms",
                "pqc_impact": "medium", 
                "alternatives": ["openssh-pqc-experimental"]
            },
            "openssh-server": {
                "category": "ssh",
                "severity": "medium",
                "reason": "Standard SSH server, no PQC algorithms", 
                "pqc_impact": "medium",
                "alternatives": ["openssh-pqc-experimental"]
            },
            
            "libcryptsetup12:amd64": {
                "category": "disk_encryption",
                "severity": "high", 
                "reason": "Disk encryption without post-quantum protection",
                "pqc_impact": "high",
                "alternatives": ["cryptsetup-pqc"]
            },
            "libcrypt1:amd64": {
                "category": "password_hashing",
                "severity": "medium",
                "reason": "Password hashing library with classical algorithms",
                "pqc_impact": "low",
                "alternatives": ["libcrypt2-pqc"]
            },
            "libgcrypt20": {
                "category": "cryptographic",
                "severity": "high",
                "reason": "GNU crypto library without PQC support",
                "pqc_impact": "high", 
                "alternatives": ["libgcrypt-pqc"]
            },
            
            "libgssapi-krb5-2": {
                "category": "authentication",
                "severity": "medium",
                "reason": "Kerberos GSSAPI without post-quantum protection",
                "pqc_impact": "medium",
                "alternatives": ["krb5-pqc"]
            },
            "libkrb5-3": {
                "category": "authentication", 
                "severity": "medium",
                "reason": "Kerberos 5 library using classical crypto",
                "pqc_impact": "medium",
                "alternatives": ["krb5-pqc"]
            },
            
            "libgnutls30": {
                "category": "tls",
                "severity": "high",
                "reason": "GnuTLS without complete PQC support",
                "pqc_impact": "high",
                "alternatives": ["gnutls-pqc"]
            },
            "libmbedtls12": {
                "category": "tls",
                "severity": "medium",
                "reason": "mbedTLS embedded crypto library",
                "pqc_impact": "medium", 
                "alternatives": ["mbedtls-pqc"]
            },

            
            "gzip": {
                "category": "compression",
                "severity": "low",
                "reason": "Compression can leak information in encrypted streams",
                "pqc_impact": "low",
                "alternatives": ["zstd", "lz4"]
            },
            "libz1": {
                "category": "compression",
                "severity": "low", 
                "reason": "Zlib compression library, potential side channels",
                "pqc_impact": "low",
                "alternatives": ["zstd", "brotli"]
            },

            
            "ca-certificates": {
                "category": "pki",
                "severity": "medium",
                "reason": "Root CA certificates may use quantum-vulnerable signatures",
                "pqc_impact": "medium",
                "alternatives": ["ca-certificates-pqc"]
            },
            "libp11-kit0": {
                "category": "pki", 
                "severity": "medium",
                "reason": "PKCS#11 library without PQC token support",
                "pqc_impact": "medium",
                "alternatives": ["p11-kit-pqc"]
            },

            
            "libcurl4": {
                "category": "networking",
                "severity": "medium",
                "reason": "HTTP library depending on OpenSSL/GnuTLS",
                "pqc_impact": "medium",
                "alternatives": ["libcurl-pqc"]
            },
            "wget": {
                "category": "networking", 
                "severity": "low",
                "reason": "Web downloader using system SSL libraries",
                "pqc_impact": "low",
                "alternatives": ["wget2-pqc"]
            },

            
            "gnupg": {
                "category": "cryptographic",
                "severity": "high",
                "reason": "GPG using RSA/ECC, vulnerable to quantum attacks",
                "pqc_impact": "high",
                "alternatives": ["gnupg-pqc", "age"]
            },
            "libnettle8": {
                "category": "cryptographic",
                "severity": "medium",
                "reason": "Low-level crypto library without PQC",
                "pqc_impact": "medium", 
                "alternatives": ["nettle-pqc"]
            }
        }

        
        self.risk_categories = {
            "cryptographic": {"weight": 1.0, "description": "Core cryptographic libraries"},
            "tls": {"weight": 0.9, "description": "TLS/SSL implementations"},
            "ssh": {"weight": 0.8, "description": "SSH and remote access"},
            "disk_encryption": {"weight": 0.7, "description": "Disk encryption tools"},
            "authentication": {"weight": 0.6, "description": "Authentication systems"},
            "pki": {"weight": 0.5, "description": "Public key infrastructure"},
            "networking": {"weight": 0.4, "description": "Network utilities"},
            "password_hashing": {"weight": 0.3, "description": "Password handling"},
            "compression": {"weight": 0.2, "description": "Compression libraries"}
        }

    def is_vulnerable(self, package_name: str) -> bool:
        if package_name in self.vulnerable_packages:
            return True

        base_name = package_name.split(':')[0]
        if base_name in self.vulnerable_packages:
            return True

        base_name = re.sub(r'\d+$', '', package_name)
        if base_name in self.vulnerable_packages:
            return True

        return False

    def get_vulnerability_info(self, package_name: str) -> Optional[Dict[str, Any]]:
        if package_name in self.vulnerable_packages:
            return self.vulnerable_packages[package_name]

        base_name = package_name.split(':')[0]
        if base_name in self.vulnerable_packages:
            return self.vulnerable_packages[base_name]

        base_name = re.sub(r'\d+$', '', package_name)
        if base_name in self.vulnerable_packages:
            return self.vulnerable_packages[base_name]

        return None

    def calculate_risk_score(self, package_name: str) -> float:
        """Calculate risk score for a vulnerable package."""
        vuln_info = self.get_vulnerability_info(package_name)
        if not vuln_info:
            return 0.0

        category = vuln_info.get('category', 'other')
        severity = vuln_info.get('severity', 'low')
        pqc_impact = vuln_info.get('pqc_impact', 'low')
        
        base_score = self.risk_categories.get(category, {"weight": 0.1})["weight"]
        
        severity_multiplier = {
            'critical': 1.0,
            'high': 0.8, 
            'medium': 0.6,
            'low': 0.4
        }.get(severity, 0.2)
        
        pqc_multiplier = {
            'high': 1.0,
            'medium': 0.7,
            'low': 0.4
        }.get(pqc_impact, 0.2)
        
        return base_score * severity_multiplier * pqc_multiplier


class PackageVulnerabilityAnalyzer:
    def __init__(self):
        self.db = PackageVulnerabilityDatabase()
        self.installed_packages = {}
        self.package_dependencies = defaultdict(set)
        self.reverse_dependencies = defaultdict(set)
        self.vulnerable_packages = set()
        self.transitively_vulnerable = set()
        self.analysis_results = {
            'total_packages': 0,
            'vulnerable_direct': 0,
            'vulnerable_transitive': 0,
            'risk_score': 0.0,
            'categories_affected': set(),
            'vulnerability_details': {},
            'dependency_chains': {},
            'recommendations': []
        }

    def query_installed_packages(self) -> Dict[str, str]:
        print("Querying installed packages...")

        try:
            
            result = subprocess.run([
                'dpkg-query', '-W', '--showformat=${Package}\t${Version}\t${Status}\n'
            ], capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                print(f"Error querying packages: {result.stderr}")
                return {}

            packages = {}
            for line in result.stdout.strip().split('\n'):
                if not line:
                    continue

                parts = line.split('\t')
                if len(parts) >= 3:
                    package_name = parts[0]
                    version = parts[1]
                    status = parts[2]

                    if 'installed' in status:
                        packages[package_name] = version

            print(f"Found {len(packages)} installed packages")
            self.installed_packages = packages
            self.analysis_results['total_packages'] = len(packages)
            return packages

        except subprocess.TimeoutExpired:
            print("Timeout querying packages")
            return {}
        except Exception as e:
            print(f"Error querying packages: {e}")
            return {}

    def query_package_dependencies(self, package_name: str) -> Set[str]:
        try:
            result = subprocess.run([
                'apt-cache', 'depends', package_name
            ], capture_output=True, text=True, timeout=10)

            if result.returncode != 0:
                return set()

            dependencies = set()
            for line in result.stdout.split('\n'):
                line = line.strip()
                if line.startswith('Depends:') or line.startswith('PreDepends:'):
                    
                    dep_part = line.split(':', 1)[1].strip()
                    
                    for alternative in dep_part.split('|'):
                        dep_name = alternative.strip().split()[0]
                        
                        dep_name = re.sub(r'\s*\([^)]*\)', '', dep_name)
                        if dep_name and dep_name in self.installed_packages:
                            dependencies.add(dep_name)
                            break
            
            return dependencies
            
        except subprocess.TimeoutExpired:
            return set()
        except Exception as e:
            return set()

    def build_dependency_graph(self) -> None:
        print("Building dependency graph...")

        total_packages = len(self.installed_packages)
        for i, package_name in enumerate(self.installed_packages.keys()):
            if i % 100 == 0:
                print(f"Processing dependencies: {i}/{total_packages}")

            dependencies = self.query_package_dependencies(package_name)
            self.package_dependencies[package_name] = dependencies

            for dep in dependencies:
                self.reverse_dependencies[dep].add(package_name)

        print("Dependency graph built")

    def identify_vulnerable_packages(self) -> None:
        print("Identifying vulnerable packages...")

        for package_name in self.installed_packages:
            if self.db.is_vulnerable(package_name):
                self.vulnerable_packages.add(package_name)
                vuln_info = self.db.get_vulnerability_info(package_name)

                self.analysis_results['vulnerability_details'][package_name] = {
                    'type': 'direct',
                    'version': self.installed_packages[package_name],
                    'vulnerability_info': vuln_info,
                    'risk_score': self.db.calculate_risk_score(package_name)
                }

                if vuln_info:
                    self.analysis_results['categories_affected'].add(vuln_info.get('category', 'unknown'))

        self.analysis_results['vulnerable_direct'] = len(self.vulnerable_packages)
        print(f"Found {len(self.vulnerable_packages)} directly vulnerable packages")

    def propagate_vulnerability(self) -> None:
        print("Propagating vulnerability through dependencies...")
        
        queue = deque(self.vulnerable_packages)
        visited = set(self.vulnerable_packages)
        
        while queue:
            current_package = queue.popleft()
            
            dependents = self.reverse_dependencies.get(current_package, set())
            
            for dependent in dependents:
                if dependent not in visited:
                    visited.add(dependent)
                    self.transitively_vulnerable.add(dependent)
                    queue.append(dependent)
                    
                    if dependent not in self.analysis_results['dependency_chains']:
                        self.analysis_results['dependency_chains'][dependent] = []
                    
                    self.analysis_results['dependency_chains'][dependent].append({
                        'vulnerable_dependency': current_package,
                        'chain_depth': self._calculate_chain_depth(dependent, current_package)
                    })
        self.analysis_results['vulnerable_transitive'] = len(self.transitively_vulnerable)
        print(f"Found {len(self.transitively_vulnerable)} transitively vulnerable packages")

    def _calculate_chain_depth(self, dependent: str, vulnerable_pkg: str) -> int:
        if dependent == vulnerable_pkg:
            return 0

        queue = deque([(dependent, 0)])
        visited = {dependent}

        while queue:
            current, depth = queue.popleft()

            if depth > 10:
                break

            dependencies = self.package_dependencies.get(current, set())

            for dep in dependencies:
                if dep == vulnerable_pkg:
                    return depth + 1

                if dep not in visited:
                    visited.add(dep)
                    queue.append((dep, depth + 1))

        return -1

    def calculate_overall_risk_score(self) -> float:
        total_score = 0.0
        
        for pkg in self.vulnerable_packages:
            total_score += self.db.calculate_risk_score(pkg)
        
        for pkg in self.transitively_vulnerable:
            
            max_risk = 0.0
            chains = self.analysis_results['dependency_chains'].get(pkg, [])
            for chain in chains:
                vuln_pkg = chain['vulnerable_dependency']
                risk = self.db.calculate_risk_score(vuln_pkg)
                depth = chain['chain_depth']
                
                discounted_risk = risk * (0.8 ** depth)
                max_risk = max(max_risk, discounted_risk)
            
            total_score += max_risk
        
        if self.analysis_results['total_packages'] > 0:
            self.analysis_results['risk_score'] = total_score / self.analysis_results['total_packages']
        
        return self.analysis_results['risk_score']

    def generate_recommendations(self) -> List[Dict[str, Any]]:
        recommendations = []
        
        crypto_packages = []
        for pkg in self.vulnerable_packages:
            vuln_info = self.db.get_vulnerability_info(pkg)
            if vuln_info is not None and vuln_info.get('category') == 'cryptographic':
                crypto_packages.append(pkg)
        
        if crypto_packages:
            recommendations.append({
                'priority': 'critical',
                'type': 'upgrade_crypto',
                'title': 'Upgrade Core Cryptographic Libraries',
                'description': f'Found {len(crypto_packages)} vulnerable crypto libraries',
                'affected_packages': crypto_packages,
                'action': 'Consider upgrading to post-quantum capable versions'
            })
        
        tls_packages = []
        for pkg in self.vulnerable_packages:
            vuln_info = self.db.get_vulnerability_info(pkg)
            if vuln_info is not None and vuln_info.get('category') == 'tls':
                tls_packages.append(pkg)
        
        if tls_packages:
            recommendations.append({
                'priority': 'high',
                'type': 'upgrade_tls', 
                'title': 'Update TLS/SSL Libraries',
                'description': f'Found {len(tls_packages)} vulnerable TLS libraries',
                'affected_packages': tls_packages,
                'action': 'Update to versions with post-quantum cipher suite support'
            })
        
        if len(self.transitively_vulnerable) > len(self.vulnerable_packages) * 3:
            recommendations.append({
                'priority': 'medium',
                'type': 'dependency_audit',
                'title': 'Audit Package Dependencies', 
                'description': f'High number of transitively vulnerable packages ({len(self.transitively_vulnerable)})',
                'affected_packages': list(self.transitively_vulnerable)[:10],
                'action': 'Review and minimize unnecessary dependencies'
            })
        
        if self.analysis_results['risk_score'] > 0.3:
            recommendations.append({
                'priority': 'medium',
                'type': 'system_hardening',
                'title': 'System-wide PQC Migration Planning',
                'description': f'Overall risk score: {self.analysis_results["risk_score"]:.2f}',
                'affected_packages': [],
                'action': 'Develop comprehensive post-quantum migration strategy'
            })
        
        self.analysis_results['recommendations'] = recommendations
        return recommendations

    def run_full_analysis(self) -> Dict[str, Any]:
        """Run complete vulnerability analysis."""
        print("Starting comprehensive package vulnerability analysis...")
        
        self.query_installed_packages()
        if not self.installed_packages:
            print("No packages found - analysis cannot continue")
            return self.analysis_results
        
        self.build_dependency_graph()
        
        self.identify_vulnerable_packages()
        
        self.propagate_vulnerability()
        
        self.calculate_overall_risk_score()
        
        
        self.generate_recommendations()
        
        print("Analysis complete")
        return self.analysis_results

    def print_summary(self) -> None:
        """Print comprehensive analysis summary."""
        results = self.analysis_results
        
        print("\n" + "="*80)
        print("PACKAGE VULNERABILITY ANALYSIS SUMMARY") 
        print("="*80)
        
        print(f"Total packages analyzed: {results['total_packages']:,}")
        print(f"Directly vulnerable packages: {results['vulnerable_direct']:,}")
        print(f"Transitively vulnerable packages: {results['vulnerable_transitive']:,}")
        print(f"Overall risk score: {results['risk_score']:.3f}")
        print()
        
        if results['vulnerable_direct'] > 0:
            print("DIRECTLY VULNERABLE PACKAGES:")
            print("-" * 40)
            
            sorted_vulns = sorted(
                results['vulnerability_details'].items(),
                key=lambda x: x[1].get('risk_score', 0),
                reverse=True
            )
            
            for pkg_name, details in sorted_vulns[:10]:  
                vuln_info = details['vulnerability_info']
                if vuln_info:
                    severity_indicator = {
                        'critical': 'ðŸ”´',
                        'high': 'ðŸŸ ', 
                        'medium': 'ðŸŸ¡',
                        'low': 'ðŸŸ¢'
                    }.get(vuln_info.get('severity', 'low'), 'âšª')
                    
                    print(f"{severity_indicator} {pkg_name:<30} "
                          f"Risk: {details['risk_score']:.3f} "
                          f"({vuln_info.get('category', 'unknown')})")
                    print(f"    {vuln_info.get('reason', 'No reason provided')}")
        
        if results['categories_affected']:
            print()
            print("AFFECTED SECURITY CATEGORIES:")
            print("-" * 35)
            for category in sorted(results['categories_affected']):
                cat_info = self.db.risk_categories.get(category, {})
                print(f"  â€¢ {category}: {cat_info.get('description', 'Unknown category')}")
        
        if results['recommendations']:
            print()
            print("SECURITY RECOMMENDATIONS:")
            print("-" * 30)
            for rec in results['recommendations']:
                priority_indicator = {
                    'critical': 'ðŸ”´',
                    'high': 'ðŸŸ ',
                    'medium': 'ðŸŸ¡', 
                    'low': 'ðŸŸ¢'
                }.get(rec['priority'], 'âšª')
                
                print(f"{priority_indicator} {rec['title']}")
                print(f"    {rec['description']}")
                print(f"    Action: {rec['action']}")

    def export_results(self, output_file: str) -> None:
        export_data = self.analysis_results.copy()
        export_data['categories_affected'] = list(export_data['categories_affected'])
        export_data['vulnerable_packages_list'] = list(self.vulnerable_packages)
        export_data['transitively_vulnerable_list'] = list(self.transitively_vulnerable)
        export_data['analysis_timestamp'] = datetime.now().isoformat()
        export_data['installed_packages'] = self.installed_packages

        try:
            with open(output_file, 'w') as f:
                json.dump(export_data, f, indent=2, default=str)
            print(f"Detailed results exported to: {output_file}")
        except Exception as e:
            print(f"Error exporting results: {e}")


def main():
    """Main function for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Analyze system packages for cryptographic vulnerabilities and PQC readiness",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  sudo python packageVulnerabilityAnalyzer.py
  sudo python packageVulnerabilityAnalyzer.py --output vulnerability_analysis.json
  sudo python packageVulnerabilityAnalyzer.py --quiet --output results.json
        """
    )

    parser.add_argument(
        '--output', '-o',
        help='Export detailed analysis results to JSON file'
    )
    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress detailed output, show only summary'
    )

    args = parser.parse_args()

    analyzer = PackageVulnerabilityAnalyzer()
    results = analyzer.run_full_analysis()
    
    if not args.quiet:
        analyzer.print_summary()
    
    if args.output:
        analyzer.export_results(args.output)
    
    if results['vulnerable_direct'] > 0:
        print(f"\nâš ï¸  Warning: {results['vulnerable_direct']} directly vulnerable packages found")
    
    if results['risk_score'] > 0.5:
        print(f"ðŸš¨ High risk system detected (score: {results['risk_score']:.3f})")


if __name__ == "__main__":
    main()